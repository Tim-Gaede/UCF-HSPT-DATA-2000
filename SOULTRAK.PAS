(***************************************************************************)
(*                      UCF ACM/UPE Fourteenth Annual                      *)
(*                    High School Programming Tournament                   *)
(*                                                                         *)
(* Problem Name: Soul Tracker                                              *)
(*                                                                         *)
(* Problem by: Eric Heimburg                                               *)
(* Solution by: Michael Kujawa                                             *)
(***************************************************************************)

Program SoulTrak;

{ A record to store what each friend has and wants.
  The bUsed member stores whether this trade has been 
  considered yet (each trade need only be considered once.)

  Note that, in graph theory, each friend corresponds to an 
  "edge" in the graph, each item corresponds to a "node" in
  the graph, and a sequence of trades is possible if a path
  exists from the "Genesis CD" to "Homogenic CD".
}
Type TFriend = Record
  Has, Wants : Integer;
  bUsed      : Boolean;
End;

var
  Items    : Array[1..100] of string;  { Used to map names to numbers }
  nItems   : Integer;
  Friends  : Array[1..20] of TFriend;  { What my friends have & want }
  nFriends : Integer;

{ AddItem
   AddItem maps an Item name to a index in the Items array, adding the Item
   name if neccessary.  An Item name will only appear once in the Items array,
   so it's index is a unique identifier for that item.
}
function AddItem(ItemName : string) : Integer;
Var
  idx : Integer;

Begin
  for idx := 1 to nItems do
    if Items[idx] = ItemName then
      begin
        AddItem := idx;
        exit;
      end;

  Inc(nItems);
  Items[nItems] := ItemName;
  AddItem := nItems;
End;





{ AddFriend
   AddFriend adds a new entry in the Friends array, which incurs two calls to
   AddItem.  AddFriend also initializes the bUsed member to false.
}
Procedure AddFriend(Has, Wants: String);
Begin
  Inc(nFriends);
  Friends[nFriends].Has := AddItem(Has);
  Friends[nFriends].Wants := AddItem(Wants);
  Friends[nFriends].bUsed := false;
End;





{ bFindAWay
   bFindAWay recurses through the list of friends trying to find a way to
   trade from 'FromItem' to 'ToItem'.  The technique used here is equivelant
   to a "Depth First Search" on a graph.  

   From a given FromItem, all the friends are looked at to see what
   ToItems can be generated by trading that FromItem.  
   
   Since, at a given level of recursion, ALL the possible ToItems are
   considered for the FromItem, those trades are marked as used so they wont be
   considered again.  Otherwise, the recursion could run forever if a cycle
   were present (A has 2, wants 1, B has 1, wants 2).
}
function bFindAWay(FromItem, ToItem : Integer) : Boolean;
var
  i : Integer;

Begin
  if FromItem = ToItem then
    Begin
      bFindAWay := true;
      exit;
    end;

  for i := 1 to nFriends do
    begin
      if (NOT Friends[i].bUsed) AND (Friends[i].Wants = FromItem) then
        Begin
          Friends[i].bUsed := true;
          if bFindAWay(Friends[i].Has, ToItem) then
            begin
              bFindAWay := true;
              exit;
            end;
        End;
    end;

  bFindAWay := false;
End;



Var
  F : Text;
  i, j, M, N : Integer;
  Has, Wants : String;
  MyCD, SatanCD : Integer;

Begin
  Assign(F, 'soultrak.in');
  reset(F);

  Readln(F, N);
  for i := 1 to N do
    begin
      nItems := 0;
      nFriends := 0;
      MyCD := AddItem('Genesis CD');
      SatanCD := AddItem('Homogenic CD');

      Readln(F, M);
      for j := 1 to M do
        begin
          Readln(F, Wants); { Throw away the name }
          Readln(F, Wants);
          Readln(F, Has);
          AddFriend(Has, Wants);
        end;

      if bFindAWay(MyCD, SatanCD) then
        Writeln('I can get my soul back!')
      else
        Writeln('I am doomed to hell for all eternity!');
    end;
End.